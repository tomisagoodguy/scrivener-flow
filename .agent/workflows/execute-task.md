---
description: 執行任務文件工作流
---

# 執行任務工作流

當用戶提供任務文件（`.agent/tasks/*.md`）時，使用此工作流執行任務。

---

## 核心心態

你擁有充足的時間。逐步完成每個項目，確保品質優先於速度。

1. **耐心執行** — 一次專注一個項目，完成後再進入下一個
2. **持續推進** — 完成一個項目後立即開始下一個，不中斷對話
3. **記錄進度** — 每完成一個項目就回來更新任務文件的進度標記
4. **完整驗收** — 所有項目完成後執行驗收標準中的測試

---

## 執行流程

### 步驟 0：執行前心態校準

// turbo

#### 🚨 核心原則：預設擁有，失敗才降級

**你預設擁有執行任務所需的一切權限和環境。**

不要問「我有沒有 X？」——直接假設你有，然後執行。
只有當命令**實際失敗**且錯誤訊息**明確指出**環境缺失時，才進行降級處理。

**跳過測試 = 任務失敗。**

---

#### 禁止的思維模式

以下想法出現時，**立即執行**而非猶豫：

| 想法 | 正確反應 |
|-----|---------|
| 「可能需要特殊配置」 | 直接跑，讓錯誤告訴你 |
| 「環境可能不完整」 | 直接跑，看實際結果 |
| 「需要 Root/特殊硬體」 | 直接跑，你預設擁有 |
| 「測試設置複雜」 | 直接跑，複雜不是跳過的理由 |
| 「這個測試可能跑不了」 | 直接跑，你的預測不重要 |

---

#### 執行流程

1. **閱讀任務文件的驗收標準** — 提取需要執行的測試命令
2. **直接執行測試** — 不需要預先檢查環境，你預設擁有所有需要的東西
3. **處理失敗**（僅當測試實際失敗時）：
   - 閱讀錯誤訊息
   - 如果是環境缺失：嘗試修復或報告給用戶
   - 如果是代碼問題：修復代碼並重新測試

---

#### 禁止行為

- ❌ 在執行測試前進行環境「預檢」
- ❌ 基於「可能」或「通常需要」假設性跳過
- ❌ 未執行就宣稱環境不支持
- ❌ 執行範例命令而非任務文件中的實際測試命令

---

### 步驟 1：閱讀任務文件

// turbo

仔細閱讀整個任務文件，理解：
- 背景與目的
- 技術決策記錄
- 實現計劃中的所有項目
- 驗收標準

### 步驟 2：規劃執行順序

// turbo

將實現計劃中的項目分成可執行的批次：

**分批原則**：

| 適合同一批次 | 必須分開 |
|-------------|---------|
| 有依賴關係的項目 | 獨立功能模組 |
| 共用相同上下文 | 需要不同前置知識 |
| 可以一起驗收 | 驗收條件完全不同 |

**分批後的結構範例**：
```
批次 1: 結構體定義 + 基礎方法
  → 完成後可驗收：cargo check 通過

批次 2: 核心業務邏輯
  → 完成後可驗收：單元測試通過

批次 3: 整合與收尾
  → 完成後可驗收：完整測試通過
```

---

### 步驟 3：執行批次

// turbo-all

對每個批次重複以下循環：

#### 3.1 執行當前批次

實現批次中的所有項目：
- 按照任務文件中的「執行過程」描述編寫代碼
- 遵循「技術決策記錄」中的選擇
- 保持與現有代碼風格一致

#### 3.2 批次驗收

執行適用於當前批次的驗收項目：
- `[build]` 項目：執行 cargo check
- `[test]` 項目：編寫並執行測試
- 確認無編譯錯誤和新增警告

#### 3.3 更新進度

回到任務文件，將已完成的項目標記為完成：
```markdown
- [x] 已完成的項目
- [ ] 尚未完成的項目
```

#### 3.4 重新閱讀任務文件

在開始下一個批次前，重新閱讀任務文件：
- 確認剩餘項目
- 確認是否有遺漏
- 確認下一個批次的內容

**立即開始下一個批次，不中斷對話。**

---

### 步驟 4：最終驗收

所有批次完成後，執行完整驗收：

#### 4.1 編譯檢查

```bash
cargo check 2>&1 | head -100
```

確認：
- 無編譯錯誤
- 無新增警告（或警告已記錄在注意事項中）

#### 4.2 執行測試

**🚨 這是最重要的步驟。用戶提供的任務文件已經過完整驗證，你只需執行。**

##### 執行清單

逐一檢查任務文件中的每個驗收項目（`AC-N`），依序執行：

1. **掃描所有 `[test]` 項目** — 列出需要執行的測試清單
2. **確認測試代碼存在** — 如果測試不存在，立即編寫（見下方編寫規則）
3. **執行測試** — 直接執行，不需要先確認
4. **標記完成** — 在任務文件中勾選 `[x]`

##### 編寫測試的正確方法

**🚨 測試驗證「規格」，不是驗證「實現」。**

| ❌ 錯誤做法 | ✅ 正確做法 |
|------------|------------|
| 看著剛寫的代碼寫測試 | **重新閱讀任務文件**，根據規格寫測試 |
| 測試通過 = 代碼正確 | 測試通過 = 代碼符合任務文件的要求 |
| 按照實現細節設計測試 | 按照任務文件描述的「預期行為」設計測試 |

**編寫測試前，必須**：
1. 回到任務文件，閱讀對應功能的「執行過程」描述
2. 根據描述中的預期行為設計測試案例
3. 測試應該能捕捉「代碼不符合規格」的錯誤

##### 禁止行為

| ❌ 禁止 | ✅ 正確做法 |
|--------|------------|
| 忘記執行某些測試 | 逐一檢查每個 `AC-N`，確保無遺漏 |
| 「這個測試需要先確認環境」 | 直接執行，環境問題讓錯誤告訴你 |
| 「這個測試可能會失敗」 | 直接執行，失敗了再修復 |
| 「我先跑部分測試」 | 執行所有測試，不跳過任何一個 |
| 問用戶「要執行這個測試嗎？」 | 任務文件已經過驗證，直接執行 |

##### 執行命令

```bash
cargo test --package [package_name] 2>&1 | head -100
```

如果任務文件指定了特定的測試命令（如 `sudo` 或特殊環境），使用任務文件中的命令。

#### 4.3 人工驗證項目

列出所有 `[manual]` 標記的項目，告知用戶需要人工確認。

---

### 步驟 5：完成報告

所有驗收通過後，向用戶報告：

```markdown
## 任務完成報告

### 已完成項目
- [x] 項目 1
- [x] 項目 2
- [x] 項目 3

### 驗收結果
- [x] cargo check 通過
- [x] 測試通過
- [ ] [manual] 需要人工確認：{描述}

### 修改的文件
- `src/foo/bar.rs` — 新增 X 功能
- `src/foo/baz.rs` — 修改 Y 方法
```

---

## 執行原則

### 持續推進

完成一個項目後，立即開始下一個：
- ✅ 「項目 A 完成，接著實現項目 B」
- ❌ 「項目 A 完成，要繼續嗎？」

### 進度追蹤

每完成一個批次，回到任務文件更新進度：
- 使用 `[x]` 標記已完成的項目
- 確保進度與實際狀態同步

### 遇到問題時

如果在執行過程中遇到：

| 情況 | 處理方式 |
|------|---------|
| 任務描述不清楚 | 根據現有代碼模式做出合理推斷，記錄決策 |
| 發現額外工作 | 完成核心任務後再處理，或記錄為後續工作 |
| 技術阻礙 | 嘗試替代方案，若無法解決則報告給用戶 |
| 測試失敗 | 修復問題後重新測試，確保通過 |

### 品質優先

- 每個批次完成後確認編譯通過
- 不留下 TODO 或 FIXME（除非任務文件明確允許）
- 代碼風格與現有代碼一致
